import com.itextpdf.text.*;
import com.itextpdf.text.pdf.PdfWriter;
import java.io.*;
import java.io.FileOutputStream;
import java.util.Scanner;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

public class TextToPdf {
	//PDF file to be generated in current directory by PDFGeneratedFromText.pdf name
	private static String FILE = "PDFGeneratedFromText.pdf";
	// Default font style to be used
	private static Font fontUsed = new Font(Font.FontFamily.TIMES_ROMAN, 12, Font.NORMAL);
	// Object of Paragraph "preface" to set the content for PDF
	private static Paragraph preface = new Paragraph();
	// Object of Sub-Paragraph for filled and indented paragraph
	private static Paragraph subPreface = new Paragraph();
	// To get value of indentation
	private static String[] splitedIndent;
	//To handle spacing after the commands
	private static boolean afterCommandSpaceEnaled = false;
	// To handle sub-paragraph addition
	private static boolean subPrefaceEnabled = false;

	public static void main(String[] args) {
		try {
			//Evaluating the text file word by word and writing to preface(Paragraph object)
			readAndEvalutionTxt();
			//Open Document to write into it
			Document document = new Document();
			//Generating the instance of the PDF file
			PdfWriter.getInstance(document, new FileOutputStream(FILE));
			//Opening the document to write the contents
			document.open();
			//Adding information about the PDF file to be generated by calling addMetaData Method
			addMetaData(document);
			//Adding information to the PDF file
			addContentToPDF(document);
			//Finally closing the Document
			document.close();
		} catch (Exception e) {
			e.printStackTrace();
		}
	}

	private static void readAndEvalutionTxt() {
		try {

			// Getting InputTextFile.txt file from current directory
			File myObject = new File("InputTextFile.txt");
			// Reading contents of file
			Scanner myReader = new Scanner(myObject);
			// Read word by word
			while (myReader.hasNextLine()) {
				String data = myReader.nextLine();
				// Check if the first letter is ".", if yes then it is a COMMAND else TEXT to be in the PDF
				if (data.substring(0, 1).equals(".")) {
					//Check for the specific command from the input file
					//Enable the space after command
					afterCommandSpaceEnaled = true;
					switch (data) {
					case ".large":
						fontUsed = new Font(Font.FontFamily.TIMES_ROMAN, 24, Font.NORMAL);
						break;
					case ".normal":
						fontUsed = new Font(Font.FontFamily.TIMES_ROMAN, 12, Font.NORMAL);
						break;
					case ".paragraph":
						//Ignore the space after new paragraph
						afterCommandSpaceEnaled = false;
						preface.add(new Paragraph("\n"));
						break;
					case ".italics":
						fontUsed = new Font(Font.FontFamily.TIMES_ROMAN, 12, Font.ITALIC);
						break;
					case ".regular":
						fontUsed = new Font(Font.FontFamily.TIMES_ROMAN, 12, Font.NORMAL);
						break;
					case ".underline":
						fontUsed = new Font(Font.FontFamily.TIMES_ROMAN, 12, Font.UNDERLINE);
						break;
					case ".bold":
						fontUsed = new Font(Font.FontFamily.TIMES_ROMAN, 12, Font.BOLD);
						break;
					case ".fill":
						subPreface.setAlignment(Element.ALIGN_JUSTIFIED);
						break;
					case ".nofill":
						preface.add(subPreface);
						//To get to the regular formatting
						subPrefaceEnabled = false;
						break;
					default:
						//Reduce the space before the sub paragraph to align properly
						subPreface.setSpacingBefore(-16f);
						//Ignore the space after the indentation
						afterCommandSpaceEnaled = false;
						// To handle command indent <number>
						if (data.contains(".indent")) {
							//Split the .indent and its value
							splitedIndent = data.split("\\s+");
							//Get its value
							int indentValue = Integer.parseInt(splitedIndent[1]);
							//If the number is positive
							if (indentValue > 0) {
								//Enabling sub paragraph to set the indentation according to value multiply by 10 
								subPrefaceEnabled = true;
								subPreface.setIndentationLeft(indentValue * 10);
							} else {
								//Resetting the indent by adding new paragraph
								preface.add(new Paragraph("\n"));
							}

						}
					}
				} else {
					//To extract Special Character
					Pattern pattern = Pattern.compile("[^a-z0-9 ]", Pattern.CASE_INSENSITIVE);
					Matcher matcher = pattern.matcher(data.substring(0, 1));
					

					//If any special character found after the command then skip the space (Example: .bold exciting, good luck!)
					if (!matcher.find() && afterCommandSpaceEnaled)
						preface.add(" ");

					// sub paragraph to to maintain indentation
					if (subPrefaceEnabled) 
						subPreface.add(new Phrase(data, fontUsed));
					else
						preface.add(new Phrase(data, fontUsed));
		
				}

				System.out.println(data);
			}
			myReader.close();
		} catch (FileNotFoundException e) {
			System.out.println("Error! File not found!");
			e.printStackTrace();
		} catch (Exception ee) {
			System.out.println("Generic error occurred!!!");
			ee.printStackTrace();
		}
	}

	//Add metadata to the PDF which can be viewed in its properties
	private static void addMetaData(Document document) {
		document.addTitle("PDF generated from instruction in TXT file");
		document.addSubject("Using iText to generate it.");
		document.addKeywords("Java, PDF, iText");
		document.addAuthor("Sanjeev Kumar");
		document.addCreator("Sanjeev Kumar");
	}

	private static void addContentToPDF(Document document) throws DocumentException {
		int totalNumberOfPdfPages=3;
		// Loop to make it a 3 page PDF
		for (int i = 0; i < totalNumberOfPdfPages; i++) {
			Paragraph forPaging = new Paragraph();
			String pageNumber = Integer.toString(i+1);
			//Font for paging
			fontUsed = new Font(Font.FontFamily.COURIER, 8);
			// page number into the header
			forPaging.add(Element.HEADER, new Paragraph("Page: "+pageNumber+" of "+totalNumberOfPdfPages+"\n\n",fontUsed));
			document.add(forPaging);
			//Add preface content to document
			document.add(preface);
			// Start a new page
			document.newPage();
		}
	}
}
